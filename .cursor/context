PROJECT CONTEXT: VB-Lin_BackEnd (tesina UAA) — estado actual y requerimientos

Resumen del estado actual (usa esto como fuente de verdad)
- Ya hay una base de datos creada localmente y en Atlas llamada "VB-Lin_BackEnd" con colecciones: users, equipment, loans, notifications. Se ejecutó un script de setup local con seeds básicos.
- En el repositorio hay package.json con scripts usando tsx y dependencias listadas (mongoose, express, jwt, redis, firebase-admin, nodemailer, jest, supertest, tsx).
- CI: ya existe un workflow en .github/workflows/ci.yml que debe ser conservado/ajustado (workflow básico tolerante).

Modelos y nombres de campos (usar exactamente estos nombres)
1) users:
  - _id (ObjectId)
  - email (string, unique)
  - passwordHash (string)
  - firstName (string)
  - lastName (string)
  - role (enum: 'estudiante'|'profesor'|'admin')
  - active (boolean)
  - createdAt (Date)
  - lastAccess (Date)

2) equipment:
  - _id (ObjectId)
  - code (string, unique)
  - name (string)
  - description (string)
  - category (string)
  - status (enum: 'disponible'|'prestado'|'mantenimiento')
  - location (string)
  - acquisitionDate (Date)
  - estimatedValue (Number)

3) loans:
  - _id (ObjectId)
  - userId (ObjectId ref users)
  - equipmentId (ObjectId ref equipment)
  - reservedAt (Date)
  - startDate (Date)
  - endDate (Date)
  - checkoutAt (Date | null)
  - returnedAt (Date | null)
  - status (enum: 'reservado'|'activo'|'devuelto'|'vencido')
  - reservationRemarks (string)
  - returnRemarks (string)

4) notifications:
  - _id (ObjectId)
  - userId (ObjectId)
  - type (enum: 'reserva'|'recordatorio'|'vencimiento')
  - message (string)
  - read (boolean)
  - sentAt (Date)

5) fcmTokens (opcional):
  - _id, userId, token, platform, createdAt

Reglas de negocio (firmes)
- Estudiantes: reserva máxima 3 días.
- Profesores: reserva máxima 7 días.
- No permitir solapamiento de reservas/activos para un mismo equipment en el rango [startDate, endDate].
- Reservas se crean con status 'reservado'. Un admin realiza checkout para marcar 'activo' (registro de checkoutAt).
- Cuando un préstamo pasa su endDate y no se devuelve, su status pasa a 'vencido' (cron job o job manual) y se notifica.
- Al crear reserva se crea notificación de tipo 'reserva' y se intenta enviar push/email (si no hay credenciales, guardar notificación y loggear envío simulado).

Endpoints esperados (implementa todos, con validaciones y ejemplos)
- Auth:
  - POST /api/auth/register  {email,password,firstName,lastName}
  - POST /api/auth/login     {email,password} -> { token, refreshToken, user }
  - POST /api/auth/refresh   { refreshToken } -> { token, refreshToken }
  - POST /api/auth/logout    { refreshToken }
  - POST /api/auth/forgot-password {email}
  - POST /api/auth/reset-password  { token, newPassword }

- Users:
  - GET /api/users?page=&limit= (admin) 
  - GET /api/users/:id
  - PUT /api/users/:id
  - DELETE /api/users/:id (admin)

- Equipment:
  - GET /api/equipment?page=&limit=&q=
  - GET /api/equipment/:id
  - POST /api/equipment (admin)
  - PUT /api/equipment/:id (admin)
  - DELETE /api/equipment/:id (admin)

- Loans:
  - GET /api/loans?page=&limit=&status=&userId=
  - GET /api/loans/:id
  - POST /api/loans/reserve { equipmentId, startDate, endDate } (auth)
  - PUT /api/loans/:id/checkout (admin) -> set checkoutAt, status 'activo'
  - PUT /api/loans/:id/return { returnRemarks? } -> set returnedAt, status 'devuelto'
  - GET /api/loans/user/:userId

- Notifications:
  - GET /api/notifications?page=&limit=
  - PUT /api/notifications/:id/read
  - POST /api/notifications/register { fcmToken } (auth)
  - POST /api/notifications/send (admin) { userId, type, message }

- Reports (admin):
  - GET /api/reports/usage?from=&to=
  - GET /api/reports/equipment-stats
  - GET /api/reports/user-activity
  - GET /api/reports/overdue

Responses & error handling
- All responses JSON: { success: boolean, data?: any, error?: string }
- Use proper HTTP codes: 200, 201, 400, 401, 403, 404, 409, 500
- On solapamiento -> 409 Conflict with message clear

Persistence of refresh tokens
- Use Redis. Key: refresh:<userId>:<refreshToken> TTL = refresh expiry
- Implement refresh token rotation, revoke old token on refresh and logout

Notifications behavior
- If FIREBASE_CREDENTIALS_PATH env points to a valid file, initialize admin SDK and send pushes.
- If not present, only store notification documents and log simulated push.

Scripts and CI expectations
- scripts/wait-for-db.ts (checks Mongo) used by CI and dev
- scripts/seed.ts creates users (admin, profesor, estudiante), equipment (5 items) and at least 1 active loan
- .github/workflows/ci.yml: keep the basic tolerant workflow (fast) already used by user
- Provide Dockerfile + docker-compose.yml (api + mongo + redis). For dev mount volume (./:/usr/src/app) and use npm run dev

Project structure expectations
- src/config (db, redis, firebase)
- src/models (mongoose schemas)
- src/services (auth, loan, notification, user, equipment)
- src/controllers (thin controllers)
- src/routes (separate files)
- src/middlewares (auth, role, validate, error)
- src/utils (jwt helpers, date helpers)
- src/index.ts (export app for tests + start server)
- tests/unit and tests/integration with jest+supertest

.env.example (must include)
PORT, NODE_ENV, JWT_SECRET, JWT_ACCESS_EXPIRES, JWT_REFRESH_SECRET, JWT_REFRESH_EXPIRES,
MONGO_URI, REDIS_HOST, REDIS_PORT, SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS, FIREBASE_CREDENTIALS_PATH, ALLOWED_ORIGINS

Deliverable requirements (Cursor output)
- Give file list created and brief purpose per file.
- Print .env.example content.
- Provide exact commands to run locally and with docker-compose.
- Provide example curl requests for login, reserve, refresh token, register fcmToken.
- Include brief testing instructions and how to run tests.

Notes for the generator
- Keep variable, function and file names consistent and idiomatic.
- Comments in Spanish.
- Avoid using Prisma; use Mongoose.
- Export express app separately (module) to allow tests to import app without listening.
- Keep code modular: services should not access req/res directly.
- Use async/await and proper try/catch error forwarding to error middleware.

Context final note:
- The user will use Cursor to generate the code and will integrate with Flutter later. The database is present and seeded locally; CI uses GitHub Actions runner. Keep code ready to run both locally (using local Mongo or Atlas via .env) and inside Docker-compose (using service hostnames 'mongo' and 'redis').
